const t=JSON.parse('{"key":"v-075f74b6","path":"/posts/2024-2-3-rust-issort-without-copy.html","title":"Rust与算法基础（2）：用Rust实现插入排序（中）","lang":"zh-CN","frontmatter":{"title":"Rust与算法基础（2）：用Rust实现插入排序（中）","date":"2024-02-03T00:00:00.000Z","category":"编程","tag":["Rust","算法"],"description":"上一集我们用泛型实现了一个参数可以是任何类型元素的数组。 实现到这里，这个sort函数已经能胜任所有数字类型的参数了，无论是isize还是usize，f32还是f64都可以用，因为它们都是原生实现了这两个特质的基础数据类型。即使是没有实现它的，也可以手动实现这两个trait再使用。 然而增加了PartialOrd和Copy限定的真的能算是“任何类型”吗？ 试想一下我们要将我们写的工具用于实际开发，写了一个限定了trait bound的函数，如果我想使用复杂的数据类型，我也得实现Copy。现在这个排序的目标是能接受所有类型，当然就包括没有Copy trait的。所以要如何做，应该先回答几个问题。","head":[["meta",{"property":"og:url","content":"https://qt911025.github.io/posts/2024-2-3-rust-issort-without-copy.html"}],["meta",{"property":"og:site_name","content":"QuenTine的博客"}],["meta",{"property":"og:title","content":"Rust与算法基础（2）：用Rust实现插入排序（中）"}],["meta",{"property":"og:description","content":"上一集我们用泛型实现了一个参数可以是任何类型元素的数组。 实现到这里，这个sort函数已经能胜任所有数字类型的参数了，无论是isize还是usize，f32还是f64都可以用，因为它们都是原生实现了这两个特质的基础数据类型。即使是没有实现它的，也可以手动实现这两个trait再使用。 然而增加了PartialOrd和Copy限定的真的能算是“任何类型”吗？ 试想一下我们要将我们写的工具用于实际开发，写了一个限定了trait bound的函数，如果我想使用复杂的数据类型，我也得实现Copy。现在这个排序的目标是能接受所有类型，当然就包括没有Copy trait的。所以要如何做，应该先回答几个问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-08T14:28:46.000Z"}],["meta",{"property":"article:author","content":"QuenTine"}],["meta",{"property":"article:tag","content":"Rust"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-02-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-08T14:28:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust与算法基础（2）：用Rust实现插入排序（中）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-02-08T14:28:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"QuenTine\\",\\"url\\":\\"https://qt911025.github.io\\"}]}"]]},"headers":[{"level":2,"title":"让目标数据实现copy trait，还是让函数支持非copy？","slug":"让目标数据实现copy-trait-还是让函数支持非copy","link":"#让目标数据实现copy-trait-还是让函数支持非copy","children":[]},{"level":2,"title":"为什么编译器不许？","slug":"为什么编译器不许","link":"#为什么编译器不许","children":[]},{"level":2,"title":"mem::take()","slug":"mem-take","link":"#mem-take","children":[{"level":3,"title":"mem::take()为什么这么神奇？","slug":"mem-take-为什么这么神奇","link":"#mem-take-为什么这么神奇","children":[]}]},{"level":2,"title":"unsafe","slug":"unsafe","link":"#unsafe","children":[]},{"level":2,"title":"还是有不行的地方","slug":"还是有不行的地方","link":"#还是有不行的地方","children":[]}],"git":{"createdTime":1707402526000,"updatedTime":1707402526000,"contributors":[{"name":"qt911025","email":"qt911025@qq.com","commits":1}]},"readingTime":{"minutes":11.05,"words":3315},"filePathRelative":"posts/2024-2-3-rust-issort-without-copy.md","localizedDate":"2024年2月3日","excerpt":"<p>上一集我们用泛型实现了一个参数可以是任何类型元素的数组。\\n实现到这里，这个sort函数已经能胜任所有数字类型的参数了，无论是isize还是usize，f32还是f64都可以用，因为它们都是原生实现了这两个特质的基础数据类型。即使是没有实现它的，也可以手动实现这两个trait再使用。</p>\\n<p>然而增加了PartialOrd和Copy限定的真的能算是“任何类型”吗？\\n试想一下我们要将我们写的工具用于实际开发，写了一个限定了trait bound的函数，如果我想使用复杂的数据类型，我也得实现Copy。现在这个排序的目标是能接受所有类型，当然就包括没有Copy trait的。所以要如何做，应该先回答几个问题。</p>","autoDesc":true}');export{t as data};
