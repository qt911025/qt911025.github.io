import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as r,c as k,d as o,w as a,a as s,b as n,e as c}from"./app-Dl7jSvyk.js";const m={},d=s("p",null,"大家好啊，今天我们就来完成《算法导论（第三版）》第八章的最后一节——桶排序。",-1),h=s("p",null,[n("当我们需要对一串大小为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mn",null,"0"),s("mo",{separator:"true"},","),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[0,1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord"},"0"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("的序列进行排序，我们可以用桶排序算法。 这一串数在这个区间中分布越平均，算法的时间复杂度就越接近"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Omicron(n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathrm"},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，而最坏情形的时间复杂度为$\\Omicron(n^2)。")],-1),v=s("p",null,[n("在输入的数据规模为n时，算法将"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mn",null,"0"),s("mo",{separator:"true"},","),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[0,1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord"},"0"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),n("区间平均划分为n份，建立n个桶。 输入的数据也被等比拉长到"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mn",null,"0"),s("mo",{separator:"true"},","),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"[0,n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord"},"0"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),n("，将n乘以输入数据并向下取整，得知这个数据会被放进几号桶。")],-1),b=s("p",null,[n("每个数据进入桶时会进行一次插入排序，这个排序的时间复杂度就是整个算法时间复杂度的最大项。 现在要实现的插入桶的过程是一个顺序查找法，所以时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"O"),s("mo",{stretchy:"false"},"("),s("msup",null,[s("mi",null,"n"),s("mn",null,"2")]),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Omicron(n^2)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathrm"},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"2")])])])])])])]),s("span",{class:"mclose"},")")])])]),n("， 而之前的例子也实现了"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"lg"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Omicron(n\\lg{n})")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathrm"},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[n("l"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n")]),s("span",{class:"mclose"},")")])])]),n("的比较排序，所以之后会逐步优化到这个速度。")],-1),g=s("h2",{id:"vec桶",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#vec桶"},[s("span",null,"Vec桶")])],-1),y=s("p",null,"在优化前先实现一个简单版的，掌握掌握思想。",-1),w=s("p",null,"桶排序像之前的实现一样，会吃掉原序列，生成新序列。 算法总共分三步：",-1),_=s("ul",null,[s("li",null,"建桶"),s("li",null,"进桶"),s("li",null,"连桶")],-1),f=s("div",{class:"language-rust line-numbers-mode","data-ext":"rs","data-title":"rs"},[s("pre",{class:"language-rust"},[s("code",null,[s("span",{class:"token keyword"},"use"),n(),s("span",{class:"token namespace"},[n("conv"),s("span",{class:"token punctuation"},"::")]),s("span",{class:"token operator"},"*"),s("span",{class:"token punctuation"},";"),n(`
`),s("span",{class:"token keyword"},"use"),n(),s("span",{class:"token namespace"},[n("issort"),s("span",{class:"token punctuation"},"::")]),s("span",{class:"token class-name"},"InsertionSorter"),s("span",{class:"token punctuation"},";"),n(`
`),s("span",{class:"token keyword"},"use"),n(),s("span",{class:"token namespace"},[n("algorithms_prelude"),s("span",{class:"token punctuation"},"::")]),s("span",{class:"token class-name"},"CompareSorter"),s("span",{class:"token punctuation"},";"),n(`

`),s("span",{class:"token keyword"},"pub"),n(),s("span",{class:"token keyword"},"fn"),n(),s("span",{class:"token function-definition function"},"bucket_sort"),s("span",{class:"token punctuation"},"("),n("arr"),s("span",{class:"token punctuation"},":"),n(),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token operator"},"<"),s("span",{class:"token keyword"},"f64"),s("span",{class:"token operator"},">"),s("span",{class:"token punctuation"},")"),n(),s("span",{class:"token punctuation"},"->"),n(),s("span",{class:"token class-name"},"Result"),s("span",{class:"token operator"},"<"),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token operator"},"<"),s("span",{class:"token keyword"},"f64"),s("span",{class:"token operator"},">"),s("span",{class:"token punctuation"},","),n(),s("span",{class:"token operator"},"&"),s("span",{class:"token lifetime-annotation symbol"},"'static"),n(),s("span",{class:"token keyword"},"str"),s("span",{class:"token operator"},">"),n(),s("span",{class:"token punctuation"},"{"),n(`
    `),s("span",{class:"token keyword"},"let"),n(" arr_length "),s("span",{class:"token operator"},"="),n(" arr"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"len"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`

    `),s("span",{class:"token comment"},"// 建桶"),n(`
    `),s("span",{class:"token keyword"},"let"),n(),s("span",{class:"token keyword"},"mut"),n(" buckets"),s("span",{class:"token punctuation"},":"),n(),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token operator"},"<"),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token operator"},"<"),s("span",{class:"token keyword"},"f64"),s("span",{class:"token operator"},">>"),n(),s("span",{class:"token operator"},"="),n(),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token punctuation"},"::"),s("span",{class:"token function"},"with_capacity"),s("span",{class:"token punctuation"},"("),n("arr_length"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
    buckets`),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"resize_with"),s("span",{class:"token punctuation"},"("),n("arr_length"),s("span",{class:"token punctuation"},","),n(),s("span",{class:"token closure-params"},[s("span",{class:"token closure-punctuation punctuation"},"|"),s("span",{class:"token closure-punctuation punctuation"},"|")]),n(),s("span",{class:"token class-name"},"Vec"),s("span",{class:"token punctuation"},"::"),s("span",{class:"token function"},"new"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`

    `),s("span",{class:"token comment"},"// 进桶"),n(`
    `),s("span",{class:"token keyword"},"for"),n(" e "),s("span",{class:"token keyword"},"in"),n(" arr "),s("span",{class:"token punctuation"},"{"),n(`
        `),s("span",{class:"token keyword"},"if"),n(" e "),s("span",{class:"token operator"},">="),n(),s("span",{class:"token number"},"0.0"),n(),s("span",{class:"token operator"},"&&"),n(" e "),s("span",{class:"token operator"},"<"),n(),s("span",{class:"token number"},"1.0"),n(),s("span",{class:"token punctuation"},"{"),n(`
            `),s("span",{class:"token keyword"},"let"),n(" bucket_id "),s("span",{class:"token operator"},"="),n(),s("span",{class:"token punctuation"},"("),n("e "),s("span",{class:"token operator"},"*"),n(),s("span",{class:"token punctuation"},"("),n("arr_length "),s("span",{class:"token keyword"},"as"),n(),s("span",{class:"token keyword"},"f64"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"approx_as"),s("span",{class:"token punctuation"},"::"),s("span",{class:"token operator"},"<"),s("span",{class:"token keyword"},"usize"),s("span",{class:"token operator"},">"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"unwrap"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
            buckets`),s("span",{class:"token punctuation"},"["),n("bucket_id"),s("span",{class:"token punctuation"},"]"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"push"),s("span",{class:"token punctuation"},"("),n("e"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
        `),s("span",{class:"token punctuation"},"}"),n(),s("span",{class:"token keyword"},"else"),n(),s("span",{class:"token punctuation"},"{"),n(`
            `),s("span",{class:"token keyword"},"return"),n(),s("span",{class:"token class-name"},"Err"),s("span",{class:"token punctuation"},"("),s("span",{class:"token string"},'"元素出界！"'),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
        `),s("span",{class:"token punctuation"},"}"),n(`
    `),s("span",{class:"token punctuation"},"}"),n(`

    `),s("span",{class:"token comment"},"// 排序每个桶，并连接"),n(`
    `),s("span",{class:"token keyword"},"let"),n(" result "),s("span",{class:"token operator"},"="),n(` buckets
        `),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"into_iter"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),n(`
        `),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"flat_map"),s("span",{class:"token punctuation"},"("),s("span",{class:"token closure-params"},[s("span",{class:"token closure-punctuation punctuation"},"|"),s("span",{class:"token keyword"},"mut"),n(" bucket"),s("span",{class:"token closure-punctuation punctuation"},"|")]),n(),s("span",{class:"token punctuation"},"{"),n(`
            `),s("span",{class:"token class-name"},"InsertionSorter"),s("span",{class:"token punctuation"},"("),s("span",{class:"token operator"},"&"),s("span",{class:"token keyword"},"mut"),n(" bucket"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"sort_by"),s("span",{class:"token punctuation"},"("),s("span",{class:"token closure-params"},[s("span",{class:"token closure-punctuation punctuation"},"|"),n("prev"),s("span",{class:"token punctuation"},","),n(" next"),s("span",{class:"token closure-punctuation punctuation"},"|")]),n(" prev "),s("span",{class:"token operator"},"<="),n(" next"),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
            bucket
        `),s("span",{class:"token punctuation"},"}"),s("span",{class:"token punctuation"},")"),n(`
        `),s("span",{class:"token punctuation"},"."),s("span",{class:"token function"},"collect"),s("span",{class:"token punctuation"},"("),s("span",{class:"token punctuation"},")"),s("span",{class:"token punctuation"},";"),n(`
    `),s("span",{class:"token class-name"},"Ok"),s("span",{class:"token punctuation"},"("),n("result"),s("span",{class:"token punctuation"},")"),n(`
`),s("span",{class:"token punctuation"},"}"),n(`
`)])]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"})])],-1),x=s("div",{class:"language-toml line-numbers-mode","data-ext":"toml","data-title":"toml"},[s("pre",{class:"language-toml"},[s("code",null,[s("span",{class:"token punctuation"},"["),s("span",{class:"token table class-name"},"package"),s("span",{class:"token punctuation"},"]"),n(`
`),s("span",{class:"token key property"},"name"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"_8_4_bucket_sort"'),n(`
`),s("span",{class:"token key property"},"version"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"0.1.0"'),n(`
`),s("span",{class:"token key property"},"edition"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"2021"'),n(`

`),s("span",{class:"token punctuation"},"["),s("span",{class:"token table class-name"},"dependencies"),s("span",{class:"token punctuation"},"]"),n(`
`),s("span",{class:"token key property"},"conv"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"0.3.3"'),n(`
`),s("span",{class:"token key property"},"issort"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token punctuation"},"{"),n(),s("span",{class:"token key property"},"path"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"../_2_1_issort"'),n(),s("span",{class:"token punctuation"},"}"),n(`
`),s("span",{class:"token key property"},"algorithms_prelude"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token punctuation"},"{"),n(),s("span",{class:"token key property"},"path"),n(),s("span",{class:"token punctuation"},"="),n(),s("span",{class:"token string"},'"../algorithms_prelude"'),n(),s("span",{class:"token punctuation"},"}"),n(`

`)])]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"}),s("div",{class:"line-number"})])],-1),M=c(`<p><code>resize_with</code>方法将数据批量填充，将arr扩充到指定大小。</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">let</span> bucket_id <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">*</span> <span class="token punctuation">(</span>arr_length <span class="token keyword">as</span> <span class="token keyword">f64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">approx_as</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这句则是一个数据转换问题，一个f64能表示的数的范围是非常大的，所以不能直接转成整型。 但这里程序是能保证这个f64转成的usize是在范围内的。Rust不支持转换，但我们可以引入<code>conv</code>库， 来转换这个数，既然已经能保证转换的数是符合大小的，就直接unwrap了。</p>`,3),O=s("blockquote",null,[s("p",null,[n("要较真的话，这依然是不安全的。f64只用52位来表示整型，当arr_length超过了"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mn",null,"5")]),s("mn",null,"2")]),s("annotation",{encoding:"application/x-tex"},"2^52")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"5")])])])])])])]),s("span",{class:"mord"},"2")])])]),n("，f64将会丢失精度，这样转换的数是不精确的。 当然相乘之后的数还是不会超限，所以不会崩溃，只是计算出来的bucket_id会不准。如果真的输入了这么长的数组的话，那就要考虑了。")])],-1),T=c(`<p>排序桶并连接这一步，用的是函数式编程方法。<code>into_iter</code>会吃掉<code>buckets</code>。 在<code>flat_map</code>中，回调输入的是<code>buckets</code>的每个元素，并且要求返回的是一个可转变成迭代器的对象， <code>flat_map</code>会将所有结果链接（<code>chain</code>）起来。</p><p>这是一个将二维数组扁平化的过程，如果是用<code>map</code>的话，还需要重新<code>collect</code>成一个二维数组再<code>concat</code>。</p><h2 id="排序更大的数" tabindex="-1"><a class="header-anchor" href="#排序更大的数"><span>排序更大的数</span></a></h2><p>我们可以通过映射的方式排序更大范围的数，只要像前面几个算法那样，能建立一个单射即可。</p><div class="language-rust line-numbers-mode" data-ext="rs" data-title="rs"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">bucket_sort</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">F</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> mapper<span class="token punctuation">:</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Result</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;static</span> <span class="token keyword">str</span><span class="token operator">&gt;</span>
    <span class="token keyword">where</span> <span class="token class-name">F</span><span class="token punctuation">:</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">f64</span>
<span class="token punctuation">{</span>
    <span class="token keyword">let</span> arr_length <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 建桶</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> buckets<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">f64</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">with_capacity</span><span class="token punctuation">(</span>arr_length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    buckets<span class="token punctuation">.</span><span class="token function">resize_with</span><span class="token punctuation">(</span>arr_length<span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 进桶</span>
    <span class="token keyword">for</span> e <span class="token keyword">in</span> arr <span class="token punctuation">{</span>
        <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token function">mapper</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> key <span class="token operator">&gt;=</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">&lt;</span> <span class="token number">1.0</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> bucket_id <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">*</span> <span class="token punctuation">(</span>arr_length <span class="token keyword">as</span> <span class="token keyword">f64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">approx_as</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            buckets<span class="token punctuation">[</span>bucket_id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token class-name">Err</span><span class="token punctuation">(</span><span class="token string">&quot;元素出界！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 排序每个桶，并连接</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> buckets
        <span class="token punctuation">.</span><span class="token function">into_iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">flat_map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token keyword">mut</span> bucket<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">{</span>
            <span class="token class-name">InsertionSorter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> bucket<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort_by</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>prev<span class="token punctuation">,</span> next<span class="token closure-punctuation punctuation">|</span></span> prev<span class="token number">.0</span> <span class="token operator">&lt;=</span> next<span class="token number">.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            bucket
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>item<span class="token closure-punctuation punctuation">|</span></span> item<span class="token number">.1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Ok</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了保证元素依然是平均分布的，元素本身得是均匀分布的，而且mapper<strong>只能是一个线性函数</strong>，让元素计算得的键仍保持均匀分布。</p>`,6),V=s("p",null,[n("插入排序已经使用了二分查找法，所以这个算法的排序最坏情形是可以提高到"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",{mathvariant:"normal"},"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"lg"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"\\Omicron(n\\lg{n})")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathrm"},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[n("l"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"n")]),s("span",{class:"mclose"},")")])])]),n("的。 但是用Vec实现的桶，毕竟是一个序列表，在内存中是紧密排列的。 当需要插入一个数据时，如果超过了容量（capacity），就会另外申请空间并拷贝过去。 而且在进行插入排序时，插入的位置越靠前，则序列需要向后整体位移的数据块就越大，这种位移是非常消耗算力的。")],-1),z=s("p",null,"所以要在此基础上优化，桶就应该用链式存储实现，下一节要实现的就是是一个链表，链表是一个只能用顺序查找插入的，所以在速度上，未必比Vec快。 而且桶排序本身适合的理想情形就是输入数据均匀分布，对于均匀分布的输入，每个桶的大小会是相当平均。 每个桶平均只有一个元素，所以插入和排序操作并不会消耗太多算力。链表化优化更多是针对最坏情形的，而越接近最坏情形，链表在排序上还是比二分查找慢。",-1),L={href:"https://rust-unofficial.github.io/too-many-lists/index.html",target:"_blank",rel:"noopener noreferrer"};function R(q,C){const l=p("Tabs"),i=p("ExternalLinkIcon");return r(),k("div",null,[d,h,v,b,g,y,w,_,o(l,{id:"38",data:[{id:"lib.rs"},{id:"Cargo.toml"}]},{title0:a(({value:t,isActive:e})=>[n("lib.rs")]),title1:a(({value:t,isActive:e})=>[n("Cargo.toml")]),tab0:a(({value:t,isActive:e})=>[f]),tab1:a(({value:t,isActive:e})=>[x]),_:1},8,["data"]),M,O,T,V,z,s("p",null,[n("所以下一节只是展示一下如何在Rust实现链表，实现链表推荐"),s("a",L,[n("这个网站"),o(i)]),n("。")])])}const Z=u(m,[["render",R],["__file","2024-4-22-bucket-sort-1.html.vue"]]),A=JSON.parse('{"path":"/posts/2024-4-22-bucket-sort-1.html","title":"Rust与算法基础（13）：桶排序（上）","lang":"zh-CN","frontmatter":{"title":"Rust与算法基础（13）：桶排序（上）","date":"2024-04-22T00:00:00.000Z","category":"编程","tag":["Rust","算法"],"description":"大家好啊，今天我们就来完成《算法导论（第三版）》第八章的最后一节——桶排序。 当我们需要对一串大小为[0,1)的序列进行排序，我们可以用桶排序算法。 这一串数在这个区间中分布越平均，算法的时间复杂度就越接近O(n)，而最坏情形的时间复杂度为$\\\\Omicron(n^2)。 在输入的数据规模为n时，算法将[0,1)区间平均划分为n份，建立n个桶。 输入的数...","head":[["meta",{"property":"og:url","content":"https://qt911025.github.io/posts/2024-4-22-bucket-sort-1.html"}],["meta",{"property":"og:site_name","content":"QuenTine的博客"}],["meta",{"property":"og:title","content":"Rust与算法基础（13）：桶排序（上）"}],["meta",{"property":"og:description","content":"大家好啊，今天我们就来完成《算法导论（第三版）》第八章的最后一节——桶排序。 当我们需要对一串大小为[0,1)的序列进行排序，我们可以用桶排序算法。 这一串数在这个区间中分布越平均，算法的时间复杂度就越接近O(n)，而最坏情形的时间复杂度为$\\\\Omicron(n^2)。 在输入的数据规模为n时，算法将[0,1)区间平均划分为n份，建立n个桶。 输入的数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-22T14:47:29.000Z"}],["meta",{"property":"article:author","content":"QuenTine"}],["meta",{"property":"article:tag","content":"Rust"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-04-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-22T14:47:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Rust与算法基础（13）：桶排序（上）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-22T14:47:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"QuenTine\\",\\"url\\":\\"https://qt911025.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Vec桶","slug":"vec桶","link":"#vec桶","children":[]},{"level":2,"title":"排序更大的数","slug":"排序更大的数","link":"#排序更大的数","children":[]}],"git":{"createdTime":1713797249000,"updatedTime":1713797249000,"contributors":[{"name":"qt911025","email":"qt911025@qq.com","commits":1}]},"readingTime":{"minutes":4.58,"words":1375},"filePathRelative":"posts/2024-4-22-bucket-sort-1.md","localizedDate":"2024年4月22日","excerpt":"<p>大家好啊，今天我们就来完成《算法导论（第三版）》第八章的最后一节——桶排序。</p>\\n<p>当我们需要对一串大小为<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mo stretchy=\\"false\\">[</mo><mn>0</mn><mo separator=\\"true\\">,</mo><mn>1</mn><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">[0,1)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mopen\\">[</span><span class=\\"mord\\">0</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mclose\\">)</span></span></span></span>的序列进行排序，我们可以用桶排序算法。\\n这一串数在这个区间中分布越平均，算法的时间复杂度就越接近<span v-pre=\\"\\" class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi mathvariant=\\"normal\\">O</mi><mo stretchy=\\"false\\">(</mo><mi>n</mi><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">\\\\Omicron(n)</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathrm\\">O</span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\">n</span><span class=\\"mclose\\">)</span></span></span></span>，而最坏情形的时间复杂度为$\\\\Omicron(n^2)。</p>","autoDesc":true}');export{Z as comp,A as data};
